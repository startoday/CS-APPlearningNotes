1. 补码：（two‘s - complement） for signed int
   浮点数计算只是近似的
 
   hex: 以0x开头的表示hex 
   0-9 A- F
      10  15
      
   十六进制的数字0代表4个二进制0
   
   eg： x = 2^n   --- n =i+4j (0<=i<=3)
                         1(i =0) 2(i=1) 4(i=2) 8(i=3) j:几个0
       如 x = 2048 =2^11  n = 3+4*2  ---> 0x800
       
   十进制与十六进制的转换：
   x--->hex    : x/16 + 余数（直接表示为16进制的数字）
   
   eg： 
   314156   = 19634 *16 +  12 （C）
            1227*16 + 2 （2）
           76 *16 +11（B）
          4*16 +12（C）
         0*16+4 （4）
         
         so total: 0x4CB2C (注意是倒叙惹！）
   
   hex --->十进制
   0x7AF = 7*16^2 + 10(A) *16^1 + F(15) * 16^0 =1967
   
  
2. 对于一个字长（word size） 为w的 机器而言 
   虚拟地址的范围是 0 -  2^w-1  (最多访问2^w 个字节  -- 如，32位，64位）
         

3. 在字 0x01234567 中
         高位  低位
         
         
   小端法：最低有效字节在前
   
   0x100 | 0x101 | 0x102 | 0x103
    67      45      23      01
    
   大端法：最高有效字节在前
   0x100 | 0x101 | 0x102 | 0x103
    01      23      45      67

4. cast 不会改变真实的指针，
   他们只是告诉编译器以新的数据类型来看待被指向的数据
   
   
5. 整数vs 浮点
   整数的二进制后除了最高有效位1外，整数的后半段与浮点数相同（*嵌*在浮点数中，浮点前/后半段可以不同）
   
 
6. *****位级运算*****
  -【BTW strlen（）不计算终止的空字符！！】
  
  ～(not,反） 
  0  - 1
  1  - 0

  &（and, p交q，与）
     0 1              0 1
   0 ? ?    --->    0 0 0
   1 ? ?            1 0 1
  
   |（or, p并q，或）
     0 1              0 1
   0 ? ?    --->    0 0 1
   1 ? ?            1 1 1
   
   ^（异或非, 两者不可同时为真）  --注意 0^0 还是0，不是1
     0 1              0 1
   0 ? ?    --->    0 0 1
   1 ? ?            1 1 0
    
    
   a^a = 0  (类似于 x + （-x）= 0）
   
